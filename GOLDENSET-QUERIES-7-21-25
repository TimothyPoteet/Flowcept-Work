queries = [
    {
        "id": 1,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLTP",
            "data_type": ["ControlFlow","Scheduling"],
            "prov_type": "Retrospective"
        },
        "query": "For each workflow execution, report the number of tasks executed, and also report the earliest task start time across all workflows.",
        "expected_response": {  
            "code": "result = df.groupby(`workflow_id`).agg(count=(`workflow_id`, count),min_started_at=(`started_at`, `min`)",
            "fields_in_code":["workflow_id","started_at"],
            "query_constructs_in_code":["groupby|agg","min|sort","count|size|length"],
              "regex_to_contain_match": [
            r"workflow_id.*task_count",  # CSV header
            r"[a-f0-9\-]{8,}.*\d+",     # UUID and count data
            r"\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}"  # Timestamp format
        ], 
            "number_of_rows":"multiple",
            "number_of_columns":"multiple"
        }
    },
    {
        "id": 2, 
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLTP",
            "data_type": ["DataFlow"],
            "prov_type": "Retrospective"
        },
        "query": "For each activity in the last workflow executed, what is the average output?",
        "expected_response": {
            "code":"result = df.groupby('activity_id')[[col for col in df.columns if col.startswith('generated.')]].mean().dropna(axis=1, how='all')",
            "fields_in_code": ["activity_id","generated."],  
            "query_constructs_in_code":["groupby|agg","mean|avg"],
            "regex_to_contain_match": [
            r"[-+]?\d*\.?\d+([eE][-+]?\d+)?"  # Any number format
        ],
            "number_of_rows":"multiple",
            "number_of_columns":"multiple"
        }
    },
    {
        "id": 3,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLTP",
            "data_type": ["Telemetry"],
            "prov_type": "Retrospective"
        },
        "query": "What is the execution time per task in the first workflow execution?",
        "expected_response": {
            "code":"result = df[df['workflow_id'] == sorted(df['workflow_id'].unique())[0]][['task_id', 'telemetry_summary.duration_sec']].values.tolist()",
            "fields_in_code": ["workflow_id","task_id","telemetry_summary.duration_sec"],
            "query_constructs_in_code":["sorted|sort"],
            "regex_to_contain_match": [
            r"task_\w+",  # Task IDs
            r"[-+]?\d*\.?\d+([eE][-+]?\d+)?"  # Duration numbers
        ],
            "number_of_rows":"multiple",
            "number_of_columns":"multiple"
        }
    },
    {
        "id": 4,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLTP",
            "data_type": ["DataFlow"],
            "prov_type": "Prospective"
        },
        "query": "Which activities use data generated by the square_and_quarter activity?", 
        "expected_response": {
            "code":"""result = pd.DataFrame(
    pd.concat([
        df[df[f'used.{col[-1]}'].isin(
            df[df['activity_id'] == 'square_and_quarter'][col].dropna().unique()
        )][['activity_id']]
        for col in df.columns
        if col.startswith('generated.') and f'used.{col[-1]}' in df.columns]).drop_duplicates().reset_index(drop=True))""",
            "fields_in_code": ["activity_id","square_and_quarter","generated.","used."],
            "query_constructs_in_code":["unique"],
            "regex_to_contain_match": [
            r"scale_shift_input|square_and_quarter|sqrt_and_scale|subtract_and_shift|square_and_subtract_one|log_and_shift|power_one_point_five|average_results",
            r"\[.*\]"  # List format
        ],  
            "number_of_rows":"one",
            "number_of_columns":"one"
        }
    },
    {
        "id": 5,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLAP",
            "data_type": ["Telemetry"],
            "prov_type": "Retrospective"
        },
        "query": "What is the activity with the longest total execution time per workflow execution?",
        "expected_response": {
            "code":"result=df.assign(started_at=pd.to_datetime(df['started_at']), ended_at=pd.to_datetime(df['ended_at']), duration=lambda x: (x['ended_at'] - x['started_at']).dt.total_seconds()).groupby(['workflow_id', 'activity_id'])['duration'].sum().reset_index().loc[lambda x: x.groupby('workflow_id')['duration'].idxmax()]",
            "fields_in_code": ["started_at","ended_at","duration","workflow_id","activity_id"],
            "query_constructs_in_code":["pd.to_datetime","groupby","sum","loc","idxmax|max"],
            "regex_to_contain_match": [
            r"workflow_id.*activity_id.*duration",  # CSV headers
            r"[a-f0-9\-]{8,}",  # Workflow IDs
            r"\w+",  # Activity IDs
            r"[-+]?\d*\.?\d+([eE][-+]?\d+)?"  # Duration values
        ],
            "number_of_rows":"multiple",
            "number_of_columns":"multiple"
        }
    },
    {
        "id": 6,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLAP",
            "data_type": ["Telemetry", "ControlFlow"],
            "prov_type": "Retrospective"
        },
        "query": "What is the longest workflow execution?",
        "expected_response": {
            "code":"result = df.assign(started_at=pd.to_datetime(df['started_at']), ended_at=pd.to_datetime(df['ended_at'])).groupby('workflow_id').apply(lambda x: (x['ended_at'].max() - x['started_at'].min()).total_seconds()).idxmax()",
            "fields_in_code": ["started_at","ended_at","workflow_id"],
            "query_constructs_in_code":["pd.to_datetime","groupby|agg","max","idxmax"],
            "regex_to_contain_match": [
            r"[a-f0-9\-]{8,}"  # Workflow ID format
        ],
            "number_of_rows":"one",
            "number_of_columns":"one"
        }
    },
    {
        "id": 7,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLAP",
            "data_type": ["Scheduling"],
            "prov_type": "Retrospective"
        },
        "query": "What node is most often used?",
        "expected_response": {
            "code":"result = df['hostname'].value_counts().idxmax()",
            "fields_in_code": ["hostname"],
            "query_constructs_in_code":["value_counts|count"],
            "regex_to_contain_match": [
            r"[a-zA-Z0-9][a-zA-Z0-9\.-]*"  # Hostname format
        ],
            "number_of_rows":"one",
            "number_of_columns":"one"
        }
    },
    {
        "id": 8,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLAP",
            "data_type": ["Telemetry"],
            "prov_type": "Retrospective"
        },
        "query": "What is the longest task, and what is it's duration?",
        "expected_response": {
            "code":"result = df.loc[df['telemetry_summary.duration_sec'].idxmax(), ['task_id', 'telemetry_summary.duration_sec']]",
            "fields_in_code": ["telemetry_summary.duration_sec", "task_id"],
            "query_constructs_in_code":["max"],
            "regex_to_contain_match": [
            r"[-+]?\d*\.?\d+([eE][-+]?\d+)?"  # Duration number
        ],
            "number_of_rows":"multiple",
            "number_of_columns":"multiple"
        }
    },
    {
        "id": 9,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLAP",
            "data_type": ["DataFlow", "ControlFlow"],
            "prov_type": "Prospective"
        },
        "query": "List all activities for all workflow runs.",
        "expected_response": {
            "code":"result = df['activity_id'].dropna().unique().tolist()",
            "fields_in_code": ["activity_id"],
            "query_constructs_in_code":["unique"],
             "regex_to_contain_match": [
            r"\w+",  # Activity names
            r"\[.*\]"  # List format
        ],
            "number_of_rows":"one",
            "number_of_columns":"one"
        }
    },
    {
        "id": 10,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLTP",
            "data_type": ["DataFlow", "ControlFlow"],
            "prov_type": "Retrospective"
        },
        "query": "What is the input and output value of the first task executed in the first workflow execution?",
        "expected_response": {
            "code":"result = df.loc[[pd.to_datetime(df['started_at']).idxmin()],['activity_id', 'used.input_value', 'generated.h']].to_dict(orient='records')[0]",
            "fields_in_code": ["started_at","activity_id","used.input_value","generated.h"],
            "query_constructs_in_code":["pd.to_datetime"],
            "regex_to_contain_match": [
            r"activity_id.*:\s*\w+",  # Activity ID in dict
            r"used\.input_value.*:\s*[-+]?\d*\.?\d+([eE][-+]?\d+)?",  # Input value
            r"generated\.h.*:\s*[-+]?\d*\.?\d+([eE][-+]?\d+)?"  # Generated value
        ],
            "number_of_rows":"one",
            "number_of_columns":"multiple"
        }
    },
    {
        "id": 11,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLTP",
            "data_type": ["Scheduling", "Telemetry"],
            "prov_type": "Retrospective"
        },
        "query": "For the workflow execution that started most recently, which node did each task run on and how long each task take?",
        "expected_response":{ 
            "code":"result = df[df['workflow_id'] == df.loc[pd.to_datetime(df['started_at']).idxmax(), 'workflow_id']].sort_values(by='started_at')[['hostname','task_id','telemetry_summary.duration_sec']].apply(tuple,axis=1).tolist()",
            "fields_in_code": ["workflow_id","started_at","hostname","task_id","telemetry_summary.duration_sec"],
            "query_constructs_in_code":["loc","pd.to_datetime","idxmax","sort_values"],
             "regex_to_contain_match": [
            r"\([^)]+,\s*[^)]+,\s*[-+]?\d*\.?\d+([eE][-+]?\d+)?\)",  # Tuple format
            r"\[.*\]"  # List format
        ],
            "number_of_rows":"multiple",
            "number_of_columns":"multiple"
        }
    },
    {
        "id": 12,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLAP",
            "data_type": ["DataFlow", "ControlFlow", "Scheduling", "Telemetry"],
            "prov_type": "Retrospective"
        },
        "query": "Provide a summary of all activities, including start times, durations, execution nodes, and output values.",
        "expected_response": {
            "code":"result = df.groupby('activity_id').agg({**{'started_at': ['min', 'max'], 'telemetry_summary.duration_sec': 'mean', 'hostname': lambda x: x.dropna().unique().tolist()}, **{col: 'max' for col in df.columns if col.startswith('generated.')}})",
            "fields_in_code": ["activity_id","started_at","telemetry_summary.duration_sec","hostname","generated."],
            "query_constructs_in_code":["groupby|agg|sortvalues","min","max","mean"],
            "regex_to_contain_match": [
            r"\w+",  # Activity names as index
            r"\d{4}-\d{2}-\d{2}",  # Date components
            r"[-+]?\d*\.?\d+([eE][-+]?\d+)?",  # Numeric values
            r"\[.*\]"  # Lists in the data
        ],
            "number_of_rows":"multiple",
            "number_of_columns":"multiple"
        }
    },
    {
        "id": 13,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLTP",
            "data_type": ["DataFlow", "ControlFlow", "Scheduling", "Telemetry"],
            "prov_type": "Retrospective"
        },
        "query": "For the first workflow execution, list all tasks with their start times, durations, nodes, and output values.",
        "expected_response": {
            "code":"result = df[df['workflow_id'] == sorted(df['workflow_id'].unique())[0]][['activity_id','started_at','telemetry_summary.duration_sec','hostname'] + [col for col in df.columns if col.startswith('generated.')]].sort_values('started_at')",
            "fields_in_code": ["workflow_id","activity_id","started_at","telemetry_summary.duration_sec","hostname","generated."],
            "query_constructs_in_code":["sorted","unique","sort_values"],
            "regex_to_contain_match": [
            r"activity_id.*started_at.*duration_sec.*hostname",  # Column headers
            r"\w+",  # Activity IDs
            r"\d{4}-\d{2}-\d{2}",  # Dates
            r"[-+]?\d*\.?\d+([eE][-+]?\d+)?"  # Numeric values
        ],
            "number_of_rows":"multiple",
            "number_of_columns":"multiple"
        }
    },
    {
        "id": 14,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLAP",
            "data_type": ["ControlFlow", "Scheduling"],
            "prov_type": "Retrospective"
        },
        "query": "For each workflow, list the unique tasks executed in the order they started, and also report how many unique campaigns there are.",
        "expected_response": {
            "code":"result = {'tasks_per_workflow': df.sort_values(['workflow_id','started_at']).groupby('workflow_id')['task_id'].apply(list), 'unique_campaign_count': df['campaign_id'].nunique()}",
            "fields_in_code": ["workflow_id","started_at","task_id","campaign_id"],
            "query_constructs_in_code":["sort_values","groupby"],
            "regex_to_contain_match": [
            r"activities_per_workflow.*:\s*\w+.*\[.*\]",  # Activities per workflow
            r"unique_campaign_count.*:\s*\d+"  # Campaign count
        ],
            "number_of_rows":"one",
            "number_of_columns":"multiple"
        }
    },
    {
        "id": 15, 
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLAP",
            "data_type": ["DataFlow"],
            "prov_type": "Retrospective"
        },
        "query": "Looking at all workflow executions, what is the minimum output value assocaited with each activity?",
        "expected_response": {
            "code":"result = df.groupby('activity_id')[[col for col in df.columns if col.startswith('generated.')]].min()",
            "fields_in_code": ["activity_id","generated."],
            "query_constructs_in_code":["groupby","apply","lambda","min","dropna"],
            "regex_to_contain_match": [
            r"scale_shift_input|square_and_quarter|sqrt_and_scale|subtract_and_shift|square_and_subtract_one|log_and_shift|power_one_point_five|average_results",
            r"[-+]?\d*\.?\d+([eE][-+]?\d+)?"  # Min values
        ],
            "number_of_rows":"multiple",
            "number_of_columns":"one"
        }
    },
    {
        "id": 16,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLTP",
            "data_type": ["Scheduling"],
            "prov_type": "Retrospective"
        },
        "query": "For the first workflow, which node did each task start on?",
        "expected_response": {
            "code":"result = df[df['workflow_id'] == sorted(df['workflow_id'].unique())[0]][['task_id', 'hostname']].drop_duplicates()",
            "fields_in_code": ["workflow_id","task_id","hostname"],
            "query_constructs_in_code":["sorted","unique","drop_duplicates"],
            "regex_to_contain_match": [
            r"task_id.*hostname",  # Column headers
            r"task_\w+",  # Task IDs
            r"[a-zA-Z0-9][a-zA-Z0-9\.-]*"  # Hostnames
        ],
            "number_of_rows":"multiple",
            "number_of_columns":"multiple"
        }
    },
    {
        "id": 17,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLAP",
            "data_type": ["ControlFlow"],
            "prov_type": "Retrospective"
        },
        "query": "Which activities ran in parallel?",
        "expected_response": {
            "code":"result = df.loc[((df[[c for c in df.columns if c.startswith('used.')]].shift() == df[[c for c in df.columns if c.startswith('used.')]]) | (df[[c for c in df.columns if c.startswith('used.')]].shift(-1) == df[[c for c in df.columns if c.startswith('used.')]])).any(axis=1), ['workflow_id','activity_id'] + [c for c in df.columns if c.startswith('used.')]]",
            "fields_in_code": ["workflow_id","activity_id","used.*"],  
            "query_constructs_in_code":["list comprehension","shift","==","|","any","loc"], 
            "regex_to_contain_match": [
            r"workflow_id.*activity_id.*used\.",  # Column pattern
            r"[a-f0-9\-]{8,}",  # Workflow IDs
            r"\w+",  # Activity IDs
            r"[-+]?\d*\.?\d+([eE][-+]?\d+)?"  # Used values
        ],
            "number_of_rows":"multiple",
            "number_of_columns":"multiple"  # Number of activities can vary, so I am using 'variable' to indicate that the number of columns is not fixed.
        }
    },
    {
        "id": 18,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLAP",
            "data_type": ["Scheduling"],
            "prov_type": "Retrospective"
        },
        "query": "Which node executed the most tasks in the latest workflow run?",
        "expected_response": {
            "code": "result = df['hostname'].value_counts().idxmax()",  
            "fields_in_code": ["hostname"],
            "query_constructs_in_code":["value_counts","idxmax"],
            "regex_to_contain_match": [
            r"[a-zA-Z0-9][a-zA-Z0-9\.-]*"  # Hostname format
        ],
            "number_of_rows":"one",
            "number_of_columns":"one"
        }
    },
    {
        "id": 19,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLTP",
            "data_type": ["DataFlow"],
            "prov_type": "Retrospective"
        },
        "query": "For each activity, return the largest value used during the last 5 workflow executions.",
        "expected_response": {
            "code":"result = df[df['workflow_id'].isin(sorted(df['workflow_id'].unique())[-5:])].groupby('activity_id')[[c for c in df.columns if c.startswith('used.')]].max()",  # FIXED: removed duplicate "result ="
            "fields_in_code": ["workflow_id","activity_id","used.*"],
            "query_constructs_in_code":["sorted","unique","isin","groupby","max","startswith"],
            "regex_to_contain_match": [
            r"activity_id",  # Index name
            r"used\.",  # Used columns
            r"[-+]?\d*\.?\d+([eE][-+]?\d+)?"  # Max values
        ],
            "number_of_rows":"multiple",
            "number_of_columns":"multiple"  # Number of activities can vary, so I am using 'variable' to indicate that the number of columns is not fixed.
        }
    },
    {
        "id": 20,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLTP",
            "data_type": ["Telemetry"],
            "prov_type": "Retrospective"
        },
        "query": "List all workflows that took longer than 2 minutes to execute.",
        "expected_response": {
            "code":"result = df.assign(started_at=pd.to_datetime(df['started_at']), ended_at=pd.to_datetime(df['ended_at'])).groupby('workflow_id').filter(lambda x: (x['ended_at'].max() - x['started_at'].min()).total_seconds() > 120)['workflow_id'].unique().tolist()",
            "fields_in_code": ["started_at","ended_at","workflow_id"],
            "query_constructs_in_code":["assign","pd.to_datetime","groupby","filter","lambda","total_seconds","unique","tolist"],
            "regex_to_contain_match": [
            r"\[.*\]",  # List format
            r"[a-f0-9\-]{8,}"  # Workflow IDs (if any)
        ],
            "number_of_rows":"multiple",
            "number_of_columns":"one"
        }
    },
    {
        "id": 21,
        "classification": {
            "who": "Human",
            "when": "Online",
            "scope": "Targeted Query",
            "query_type": "OLTP",
            "data_type": ["Telemetry"],
            "prov_type": "Retrospective"
        },
        "query": "For the last 10 workflow executions, what was the average percentage of cpu used.",
        "expected_response": {
            "code":"result = df[(df['workflow_id'].isin(df['workflow_id'].unique()[-10:])) & (df['telemetry_summary.cpu.percent_all_diff'].notna())][['telemetry_summary.cpu.percent_all_diff']].mean()",
            "fields_in_code": ["workflow_id","telemetry_summary.cpu.percent_all_diff"],
            "query_constructs_in_code":["isin","pd..unique","notna","mean"],
            "regex_to_contain_match": [
            r"[-+]?\d*\.?\d+([eE][-+]?\d+)?"  # Mean CPU percentage
        ],
            "number_of_rows":"one",
            "number_of_columns":"one"
        }
    }
]
